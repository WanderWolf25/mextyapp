This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
appsettings.json
documentacion/PlugAndPlay.md
documentacion/ReglasGlobales.docx
documentacion/RolesReglas.docx
documentacion/UsoEFCore.md
sql/init.sql
src/Infrastructure/Entities/User.cs
src/Infrastructure/Entities/UserRole.cs
src/Infrastructure/MexyContextDb.cs
src/Program.cs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="appsettings.json">
{
  "ConnectionStrings": {
    "Default": "Host=aws-0-us-west-2.pooler.supabase.com;Port=6543;Database=postgres;Username=postgres.gvpahcbsrfjruindyzvu;Password=PoderosaMexyApp#Artesania?25;Ssl Mode=Require;Trust Server Certificate=true"
  }
}
</file>

<file path="documentacion/PlugAndPlay.md">
PlugAndPlay

# Base de Datos

    Si queremos cambiar la base de datos a la que apunta el backend tenemos que modificar el archivo**appsettings.json**. ahi podemos especificar las credenciales tipo de base de datos y la direccion y puerto de esta, en este caso usamos supabase
</file>

<file path="documentacion/UsoEFCore.md">
// EF Core (Entity Framework Core) es un ORM de .NET

/* ¿Qué es un ORM?

   Es como un traductor entre tu código y la base de datos.

   Tú trabajas con clases (User, Product, etc.) y EF Core se encarga de:

- Convertir tus consultas LINQ en SQL
- Insertar, actualizar y borrar datos
- Mapear filas de la DB a objetos C# y viceversa

   ¿Para qué sirve?

- Evitas escribir SQL manual en cada operación
- Mapeas tablas ↔ clases
- Migraciones: actualizas el esquema desde código
- Funciona con varias DB: SQL Server, PostgreSQL, MySQL, SQLite...

   Conceptos clave:

1) DbContext → Es la “puerta” a la DB, tu sesión de trabajo

   public class AppDbContext : DbContext {

   public DbSet`<User>` Users => Set`<User>`();

   }
2) DbSet`<T>` → Representa una tabla (ej: db.Users = tabla Users)
3) LINQ → SQL

   var user = await db.Users.FirstOrDefaultAsync(x => x.Email == email);

   // EF genera: SELECT TOP(1) * FROM Users WHERE Email = ...
4) Migraciones → Scripts para crear/actualizar tablas desdecódigo

   Diferenciarápida:

   -EFclásico(EF6):viejo,ligadoa.NETFramework

   -EFCore:moderno,multiplataforma,recomendadohoy

   ¿Porqué apareceprivateUser(){}// EF?

   PorqueEFnecesitacrearobjetosUsercuandoleedelaDB.

   Eseconstructorvacíoesla “puerta” paraEF,perolohacemosprivate

   paraquenadiemáspuedacrearUsersvacíosyromperreglas.

   SinousasEFCore,opciones:

   -Dapper(másmanual,rápido)

   -SQLdirectoconADO.NET

   Paraproyectosnuevos,EFCoreaceleramuchoelCRUDymigraciones.

*/
</file>

<file path="sql/init.sql">

</file>

<file path="src/Infrastructure/Entities/User.cs">
namespace MexyApp.Models;
public enum RoleName { Comprador, Artesano, Soporte, Administrador }
public enum UserStatus { Activo, Bloqueado } // “Inactivo/Suspendido” suele duplicar Bloqueado

public class User
{
    public int Id { get; private set; }

    public string Username { get; private set; } = default!;
    public string Email { get; private set; } = default!;
    public string PasswordHash { get; private set; } = default!;

    public UserStatus Status { get; private set; } = UserStatus.Activo;

    private readonly HashSet<RoleName> _roles = new();/* Esto no es mas que una lista,vector,array o como le quieras llamar.
    la unica diferencia es que, solo se puede agregar elementos una vez de ese mismo valor, si hay un repetido devolvera
    un false, esto es muy util para evitar duplicados  y que guardemos todos los roles que tendra cada usuario.
    el readonly despues de private simplemente significa que no se puede reasignar el tipo a otro, pero si podemos hacer
    add y todo lo que hariamos en una lista normal*/
    public IReadOnlyCollection<RoleName> Roles => _roles;/* creamos una nueva coleccion de solo lectura,
    y el valor que le asignamos es cualquier valor nuevo o viejo que contenga _roles, esto es para que no puedan modificar
    los roles desde afuera de la clase. */

    

    private User() { } // EF
    
// EF
/* Esto es un constructor VACÍO (sin parámetros).
   ¿Para qué sirve? Para que Entity Framework (EF Core) pueda crear un User
   cuando lee datos de la base de datos.

   Piensa en EF como “un cargador de objetos”:
   - EF hace un SELECT a la tabla Users
   - Luego necesita construir un objeto User en memoria
   - Para construirlo, normalmente necesita un constructor sin parámetros
   - Después de crearlo, EF le mete los valores (Id, Email, etc.)

   ¿Por qué es private?
   Porque tú NO quieres que cualquier parte del código pueda hacer:
       new User()
   y dejar el objeto a medias o inválido (sin email, sin roles, etc.)

   Entonces:
   - EF sí lo puede usar (usa reflexión y puede entrar aunque sea private)
   - Tu código normal NO lo puede usar (porque private lo bloquea)
   Resultado: EF puede hidratar la entidad, pero tú controlas cómo se crea “bien”.
*/


    public User(string username, string email, string passwordHash)
    {
        Username = username.Trim();
        Email = email.Trim().ToLowerInvariant();
        PasswordHash = passwordHash;
        _roles.Add(RoleName.Comprador); // rol base típico
    }

    public bool HasRole(RoleName role) => _roles.Contains(role);

    public void AddRole(RoleName role) => _roles.Add(role);

    public void Block() => Status = UserStatus.Bloqueado;
}
</file>

<file path="src/Infrastructure/Entities/UserRole.cs">
namespace MexyApp.Models;

public class UserRole
{
    public int UserId { get; set; }
    public RoleName Role { get; set; }
    public User? User { get; set; } // navegación opcional

    public UserRole() { } // constructor vacío para EF
}
</file>

<file path="src/Infrastructure/MexyContextDb.cs">
using Microsoft.EntityFrameworkCore;
using MexyApp.Models;

namespace MexyApp.Api.Domain
{
    public sealed class MexyContext : DbContext
    {
        public MexyContext(DbContextOptions<MexyContext> options) : base(options) { }

        public DbSet<User> Users => Set<User>();
        public DbSet<UserRole> UserRoles => Set<UserRole>();

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.HasDefaultSchema("public"); // explícito para Supabase

            modelBuilder.Entity<User>(b =>
            {
                b.ToTable("Users");
                b.HasKey(u => u.Id);

                b.Property(u => u.Username).HasMaxLength(100).IsRequired();
                b.Property(u => u.Email).HasMaxLength(256).IsRequired();
                b.HasIndex(u => u.Email).IsUnique();

                b.Property(u => u.PasswordHash).HasMaxLength(256).IsRequired();

                b.Property(u => u.Status)
                 .HasConversion<string>()
                 .HasMaxLength(20)
                 .IsRequired();
            });

            modelBuilder.Entity<UserRole>(b =>
            {
                b.ToTable("UserRoles");
                b.HasKey(ur => new { ur.UserId, ur.Role });

                b.Property(ur => ur.Role)
                 .HasConversion<string>()
                 .HasMaxLength(50)
                 .IsRequired();

                b.HasOne(ur => ur.User)
                 .WithMany()
                 .HasForeignKey(ur => ur.UserId)
                 .OnDelete(DeleteBehavior.Cascade);
            });
        }
    }
}
</file>

<file path="src/Program.cs">
using MexyApp.Api.Domain;
using MexyApp.Models;
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddDbContext<MexyContext>(opt =>
    opt.UseNpgsql(builder.Configuration.GetConnectionString("Default"))
);

var app = builder.Build();

// ÚNICO endpoint: crea usuario con hash BCrypt
app.MapGet("/crear-usuario", async (string username, string email, string password, MexyContext db) =>
{
    var hash = BCrypt.Net.BCrypt.HashPassword(password);
    var user = new User(username, email, hash);
    db.Users.Add(user);
    await db.SaveChangesAsync();
    return $"Usuario creado con ID: {user.Id}";
});

app.Run();
</file>

</files>
